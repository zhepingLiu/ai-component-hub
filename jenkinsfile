def docker_registry_url = '' // TODO: 填写你的镜像仓库
def docker_registry_credential = '' // TODO: 如需登录仓库
def docker_info = 'kjb-docker-dev'
def docker_image = docker_registry_url ? "${docker_registry_url}/docker:24.0" : "docker:24.0"
def label = "docker-${UUID.randomUUID().toString()}"

properties([
  disableConcurrentBuilds(),
  buildDiscarder(logRotator(numToKeepStr: '30', artifactNumToKeepStr: '10'))
])

podTemplate(
  label: label,
  containers: [
    containerTemplate(name: 'docker', image: docker_image, command: 'cat', ttyEnabled: true)
  ],
  serviceAccount: 'jenkins-admin',
  volumes: [
    hostPathVolume(mountPath: '/var/run/docker.sock', hostPath: '/var/run/docker.sock')
  ]
) {
  node(label) {
    container('docker') {
      env.REGISTRY = docker_registry_url ?: 'registry.intra.example.com'
      env.IMAGE_NS = 'ai-component-hub'
      env.DOCKER_BUILDKIT = '1'
      env.COMPOSE_DOCKER_CLI_BUILD = '1'

      stage('Checkout') {
        checkout scm
        sh 'git rev-parse --short HEAD > .git_short_sha'
      }

      stage('Compute Image Tags') {
        def sha = readFile('.git_short_sha').trim()
        def branch = (env.BRANCH_NAME ?: 'unknown').replaceAll('[^0-9A-Za-z_.-]', '-')
        env.GIT_SHA_SHORT = sha
        env.SAFE_BRANCH = branch
        env.IMAGE_TAG = "${branch}-${sha}"
        echo "REGISTRY=${env.REGISTRY}"
        echo "IMAGE_NS=${env.IMAGE_NS}"
        echo "BRANCH_NAME=${env.BRANCH_NAME}"
        echo "IMAGE_TAG=${env.IMAGE_TAG}"
      }

      stage('Detect Changes') {
        // Multibranch 在 PR 场景通常有 CHANGE_TARGET；普通分支构建没有
        def target = env.CHANGE_TARGET
        def diffBase = target ? "origin/${target}" : "HEAD~1"

          // 取变更文件列表；首次构建/找不到 diffBase 时，直接全量构建
          def changed = ''
          try {
            sh "git fetch --all --prune"
            changed = sh(script: "git diff --name-only ${diffBase}..HEAD", returnStdout: true).trim()
          } catch (err) {
            echo "Diff base unavailable (${diffBase}). Fallback to full build."
            changed = '__FULL_BUILD__'
          }

          env.CHANGED_FILES = changed
          echo "Changed files:\n${env.CHANGED_FILES}"

          // 计算哪些组件需要构建
          env.BUILD_GATEWAY = (changed.contains('__FULL_BUILD__') || changed.readLines().any { it.startsWith('gateway/') }) ? 'true' : 'false'
          env.BUILD_TOOLS_BASIC = (changed.contains('__FULL_BUILD__') || changed.readLines().any { it.startsWith('components/tools-basic/') }) ? 'true' : 'false'
          env.BUILD_ESB = (changed.contains('__FULL_BUILD__') || changed.readLines().any { it.startsWith('components/esb/') }) ? 'true' : 'false'
        env.BUILD_NGINX = (changed.contains('__FULL_BUILD__') || changed.readLines().any { it.startsWith('nginx/') }) ? 'true' : 'false'
        env.BUILD_ORCHESTRATOR = (changed.contains('__FULL_BUILD__') || changed.readLines().any { it.startsWith('orchestrator/') }) ? 'true' : 'false'

          // 如果改的是根目录公共文件（如 docker-compose.yml、共享脚本），通常需要全量构建
          if (changed.readLines().any { it == 'docker-compose.yml' || it == 'Jenkinsfile' || it.startsWith('.github/') }) {
            env.BUILD_GATEWAY = 'true'
            env.BUILD_TOOLS_BASIC = 'true'
            env.BUILD_ESB = 'true'
            env.BUILD_NGINX = 'true'
            env.BUILD_ORCHESTRATOR = 'true'
          }

        echo "Build flags: gateway=${env.BUILD_GATEWAY}, tools-basic=${env.BUILD_TOOLS_BASIC}, esb=${env.BUILD_ESB}, nginx=${env.BUILD_NGINX}, orchestrator=${env.BUILD_ORCHESTRATOR}"
      }

      stage('Build Images (Parallel)') {
        def tasks = [:]

        if (env.BUILD_GATEWAY == 'true') {
          tasks['Build gateway'] = {
            if (!env.IMAGE_TAG) { error 'IMAGE_TAG is empty' }
            def image = "${env.REGISTRY}/${env.IMAGE_NS}/gateway:${env.IMAGE_TAG}"
            sh """
              set -eu
              docker build -t ${image} -f gateway/Dockerfile .
            """
            echo "Built: ${image}"
          }
        }

        if (env.BUILD_TOOLS_BASIC == 'true') {
          tasks['Build tools-basic'] = {
            if (!env.IMAGE_TAG) { error 'IMAGE_TAG is empty' }
            def image = "${env.REGISTRY}/${env.IMAGE_NS}/tools-basic:${env.IMAGE_TAG}"
            sh """
              set -eu
              docker build -t ${image} -f components/tools-basic/Dockerfile .
            """
            echo "Built: ${image}"
          }
        }

        if (env.BUILD_ESB == 'true') {
          tasks['Build esb'] = {
            if (!env.IMAGE_TAG) { error 'IMAGE_TAG is empty' }
            def image = "${env.REGISTRY}/${env.IMAGE_NS}/esb:${env.IMAGE_TAG}"
            sh """
              set -eu
              docker build -t ${image} -f components/esb/Dockerfile .
            """
            echo "Built: ${image}"
          }
        }

        if (env.BUILD_NGINX == 'true') {
          tasks['Build nginx'] = {
            if (!env.IMAGE_TAG) { error 'IMAGE_TAG is empty' }
            def image = "${env.REGISTRY}/${env.IMAGE_NS}/nginx:${env.IMAGE_TAG}"
            sh """
              set -eu
              docker build -t ${image} -f nginx/Dockerfile .
            """
            echo "Built: ${image}"
          }
        }

        if (env.BUILD_ORCHESTRATOR == 'true') {
          tasks['Build orchestrator'] = {
            if (!env.IMAGE_TAG) { error 'IMAGE_TAG is empty' }
            def image = "${env.REGISTRY}/${env.IMAGE_NS}/orchestrator:${env.IMAGE_TAG}"
            sh """
              set -eu
              docker build -t ${image} -f orchestrator/Dockerfile .
            """
            echo "Built: ${image}"
          }
        }

        if (tasks.isEmpty()) {
          echo 'No images to build.'
        } else {
          parallel tasks
        }
      }
    }
  }
}
