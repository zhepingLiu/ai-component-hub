pipeline {
  agent any

  options {
    timestamps()
    ansiColor('xterm')
    disableConcurrentBuilds()
    buildDiscarder(logRotator(numToKeepStr: '30', artifactNumToKeepStr: '10'))
  }

  environment {
    // ====== 你们内网镜像仓库（按需改）======
    REGISTRY = 'registry.intra.example.com'
    IMAGE_NS = 'ai-component-hub'

    // ====== Docker BuildKit（建议开启）======
    DOCKER_BUILDKIT = '1'
    COMPOSE_DOCKER_CLI_BUILD = '1'
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
        sh 'git rev-parse --short HEAD > .git_short_sha'
      }
    }

    stage('Compute Image Tags') {
      steps {
        script {
          def sha = readFile('.git_short_sha').trim()
          def branch = (env.BRANCH_NAME ?: 'unknown').replaceAll('[^0-9A-Za-z_.-]', '-')
          env.GIT_SHA_SHORT = sha
          env.SAFE_BRANCH  = branch
          env.IMAGE_TAG    = "${branch}-${sha}"
          echo "BRANCH_NAME=${env.BRANCH_NAME}"
          echo "IMAGE_TAG=${env.IMAGE_TAG}"
        }
      }
    }

    stage('Detect Changes') {
      steps {
        script {
          // Multibranch 在 PR 场景通常有 CHANGE_TARGET；普通分支构建没有
          def target = env.CHANGE_TARGET
          def diffBase = target ? "origin/${target}" : "HEAD~1"

          // 取变更文件列表；首次构建/找不到 diffBase 时，直接全量构建
          def changed = ''
          try {
            sh "git fetch --all --prune"
            changed = sh(script: "git diff --name-only ${diffBase}..HEAD", returnStdout: true).trim()
          } catch (err) {
            echo "Diff base unavailable (${diffBase}). Fallback to full build."
            changed = '__FULL_BUILD__'
          }

          env.CHANGED_FILES = changed
          echo "Changed files:\n${env.CHANGED_FILES}"

          // 计算哪些组件需要构建
          env.BUILD_GATEWAY = (changed.contains('__FULL_BUILD__') || changed.readLines().any { it.startsWith('gateway/') }) ? 'true' : 'false'
          env.BUILD_TOOLS_BASIC = (changed.contains('__FULL_BUILD__') || changed.readLines().any { it.startsWith('components/tools-basic/') }) ? 'true' : 'false'
          env.BUILD_ESB = (changed.contains('__FULL_BUILD__') || changed.readLines().any { it.startsWith('components/esb/') }) ? 'true' : 'false'
          env.BUILD_NGINX = (changed.contains('__FULL_BUILD__') || changed.readLines().any { it.startsWith('nginx/') }) ? 'true' : 'false'

          // 如果改的是根目录公共文件（如 docker-compose.yml、共享脚本），通常需要全量构建
          if (changed.readLines().any { it == 'docker-compose.yml' || it == 'Jenkinsfile' || it.startsWith('.github/') }) {
            env.BUILD_GATEWAY = 'true'
            env.BUILD_TOOLS_BASIC = 'true'
            env.BUILD_ESB = 'true'
            env.BUILD_NGINX = 'true'
          }

          echo "Build flags: gateway=${env.BUILD_GATEWAY}, tools-basic=${env.BUILD_TOOLS_BASIC}, esb=${env.BUILD_ESB}, nginx=${env.BUILD_NGINX}"
        }
      }
    }

    stage('Build Images (Parallel)') {
      parallel {
        stage('Build gateway') {
          when { expression { env.BUILD_GATEWAY == 'true' } }
          steps {
            script {
              def image = "${env.REGISTRY}/${env.IMAGE_NS}/gateway:${env.IMAGE_TAG}"
              sh """
                set -euo pipefail
                docker build -t ${image} -f gateway/Dockerfile .
              """
              echo "Built: ${image}"
            }
          }
        }

        stage('Build tools-basic') {
          when { expression { env.BUILD_TOOLS_BASIC == 'true' } }
          steps {
            script {
              def image = "${env.REGISTRY}/${env.IMAGE_NS}/tools-basic:${env.IMAGE_TAG}"
              sh """
                set -euo pipefail
                docker build -t ${image} -f components/tools-basic/Dockerfile .
              """
              echo "Built: ${image}"
            }
          }
        }

        stage('Build esb') {
          when { expression { env.BUILD_ESB == 'true' } }
          steps {
            script {
              def image = "${env.REGISTRY}/${env.IMAGE_NS}/esb:${env.IMAGE_TAG}"
              sh """
                set -euo pipefail
                docker build -t ${image} -f components/esb/Dockerfile .
              """
              echo "Built: ${image}"
            }
          }
        }

        stage('Build nginx') {
          when { expression { env.BUILD_NGINX == 'true' } }
          steps {
            script {
              def image = "${env.REGISTRY}/${env.IMAGE_NS}/nginx:${env.IMAGE_TAG}"
              sh """
                set -euo pipefail
                docker build -t ${image} -f nginx/Dockerfile .
              """
              echo "Built: ${image}"
            }
          }
        }
      }
    }

    // ====== 可选：Push 镜像（建议先关掉，等你配好凭证再打开）======
    // stage('Push Images') {
    //   when { anyOf { branch 'main'; branch 'master'; branch 'release/*' } }
    //   steps {
    //     withCredentials([usernamePassword(credentialsId: 'docker-registry-creds', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
    //       sh """
    //         echo "$DOCKER_PASS" | docker login ${REGISTRY} -u "$DOCKER_USER" --password-stdin
    //       """
    //     }
    //
    //     script {
    //       if (env.BUILD_GATEWAY == 'true')     sh "docker push ${REGISTRY}/${IMAGE_NS}/gateway:${IMAGE_TAG}"
    //       if (env.BUILD_TOOLS_BASIC == 'true') sh "docker push ${REGISTRY}/${IMAGE_NS}/tools-basic:${IMAGE_TAG}"
    //       if (env.BUILD_ESB == 'true')         sh "docker push ${REGISTRY}/${IMAGE_NS}/esb:${IMAGE_TAG}"
    //       if (env.BUILD_NGINX == 'true')       sh "docker push ${REGISTRY}/${IMAGE_NS}/nginx:${IMAGE_TAG}"
    //     }
    //   }
    // }
  }

  post {
    always {
      sh 'docker image prune -f || true'
    }
    success {
      echo "Build succeeded: ${env.IMAGE_TAG}"
    }
    failure {
      echo "Build failed"
    }
  }
}
